---
title: "Dasatinib Metagenes"
author: "Kieran Redpath"
date: "23 March 2025"
output:
  html_document:
    theme: cosmo
    toc: true
    toc_depth: 3
    toc_float: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Summary

* __Dasatinib:__
+ The expression data for 37 gastric and breast cancer cell lines (for all genes) was taken from the CCLE. Not all of these were susceptible to dasatinib, but they all have data for it, amongst other drugs. All 37 cell lines (instead of the roughly half that which were susceptible) were chosen to increase the sample size, and still account for gene expression changes/drug susceptibility between tissue types.
+ These data were used to weight the data from all CCLE cell lines using linear algebra (matrix multiplication). This means that the gene expression values from these tissues are effectively worth more, giving a view that's skewed towards breast/stomach cells.

* __Metagenes:__
+ After cutting down the full list of cell lines to only those that had both GDSC and CCLE data, a matrix of the strength of the correlation between a drug and a pathway metagene (creating with an SVD to reduce the dimensions of every single gene involved in the metagene) was created. The pathways analysed were specifically those that were found to be involved in dasatinib response from previous research. This helped identify drugs that are strongly linked to dasatinib target pathways.
+ The strongest drug/pathway correlations (Spearman > 0.4) were identified. However, there were too many to validate experimentally.

* __MetaPathways:__
+ To solve these problems, MetaPathways were created. If a metagene represents the expression of all the genes in a pathway, a MetaPathway represents all the metagene values from a set of clustered pathways (4 MetaPathways represent the entire set of 76 pathways). This also means that very similar pathways are now represented by the same value. Similarly to earlier, a matrix of drug/MetaPathway correlations was created to find the strongest interactions.
+ The gene expression values that contribute to a MetaPathway only include those genes that are part of multiple pathways within the MetaPathway. This means that some of the less significant (in relation to dasatinib) pathways aren't represented (as they only had one or two genes), which is good.
+ Heatmaps of MetaPathways were then created, including information on drug AUC, CDH1 expression, and MetaPathway value. This gives a much more reasonably sized list of potentially significant drugs.
+ The MetaPathways were also created using SVD, and account for roughly 30% of the variation in the data in the first two axes.

* __Unweighted MetaPathways:__
+ To explore the effects of weighting the data with breast/gastric cancer cell lines, MetaPathways were also created without using matrix multiplication. This gives a slightly different (and larger) list of significant drug/MetaPathway correlations, but these are less likely to be important specifically in breast/gastric cancer.
+ There is a strong link between the weighted and unweighted MetaPathway values, which is unsurprising as breast/gastric cell lines are only a small proportion of those overall.

* __Notes for MetaPathways in General:__
+ Low AUC means that there is a low percentage of cells that survive. Therefore, low AUC means a drug is effective.
+ Anything with a high value should be represented by a light colour, anything with a low value should be represented by a dark colour.
+ expressioncols/drugAUC -> direction should be 1. Check the colour codes, light (FFEA46FF) should be in the right spot for High AUC.
+ Metapathwaycols/MetaPathwayValue -> direction should be 1.
+ Metapathwaycontentscols/Metapathwaycontentsvalue -> direction should be 1.
+ CDH1Expressioncols/CDH1Expression -> direction should be 1.
+ CDH1Levelcols/CDH1Level -> direction should be -1. Check the colour codes, light (F0F921FF) should be in the right spot for high CDH1 level.


## Setup
### Load Packages
```{r, results = "hide", message = FALSE, warning = FALSE}
# Load packages.
library(limma)
library(edgeR)
library(data.table)
library(magrittr)
library(ggplot2)
library(CePa)
library(tidyverse)
library(dplyr)
library(org.Hs.eg.db)
library(reactome.db)
library(goseq)
library(gplots)
source('Data/heatmap-mik.R')
library(knitr)
library(evaluate)
library(kableExtra)
library(devtools)
library(viridis)
set.seed(42)
```

### Load Data
```{r, results = "hide", message = FALSE, warning = FALSE}
expDat_Dasatinib <- read.csv("Data/BRCA_STAD_Das_Expression_Data.csv", row.names = 1)
GeneLabelToolDasatinib <- read.csv("Data/Gene_Label_Tool.csv", row.names = 1)
goseqPathways <- read.csv("Data/goseq_Das_Pathways.csv", row.names = 1)
ensginPaths <- readRDS("Data/Ensembl_ID_in_Paths.Rds")

# Load raw data, and normalise raw expression data.
ccleExpData <- read.gct('Data/CCLE_RNAseq_genes_counts_20180929.gct')
# Remove X's from cell lines that start with a number.
colnames(ccleExpData) <- sub("^X", "", colnames(ccleExpData))

# Normalise with the edgeR and limma packages.
dge <- DGEList(counts = ccleExpData)
dge <- calcNormFactors(dge)
dge_voom <- voom(dge, plot = FALSE)
expDat <- dge_voom$E

# Create copies of "expDat", to be used later.
expDatAll <- expDatRaw <- expDat
# Rename expDat so that the cell line names don't include tissue type (for matching purposes).
colnames(expDat) <- strsplit(colnames(expDat), "_") %>% 
  lapply(., function(x) x[1]) %>% 
  unlist()

# Load drug data.
GDSC2 <- fread("Data/GDSC2_fitted_dose_response_25Feb20.csv", sep= ';')
# Load human gene data.
hs <- org.Hs.eg.db
```

### Create Tools for Matching
```{r, message = FALSE}
# Create "tissueTool", for matching cell line name and tissue type.
lng <- (colnames(expDatRaw)) %>% length(.)
tissueTool <- data.frame(Cell_Line = character(lng), Tissue_Type = character(lng))
tissueTool$Cell_Line <- strsplit(colnames(expDatRaw), "_") %>% 
  lapply(., function(x) x[1]) %>% 
  unlist()
tissueTool$Tissue_Type <- strsplit(colnames(expDatRaw), "_") %>% 
  lapply(., function(x) x[-1]) %>% 
  paste(., sep = "_", collapse = NULL) %>% 
  unlist()
tissueTool$Tissue_Type <- gsub('c', '', tissueTool$Tissue_Type) %>% 
  gsub('[[:punct:]]', '', .) %>% 
  gsub(' ', '_', .)
int <- intersect(colnames(expDat), tissueTool$Cell_Line)
mtch <- match(int, tissueTool$Cell_Line)
tissueTool <- tissueTool[na.omit(mtch) , ]
# Add two extra columns to "tissueTool", one for CDH1 expression values, one for CDH1 expression status.
expDat_Dup <- expDat[ , !duplicated(colnames(expDat))]
tissueTool$CDH1_Expression <- expDat_Dup %>% as.data.frame(.) %>% dplyr::select(., which(colnames(.) %in% tissueTool$Cell_Line)) %>%  .["ENSG00000039068.14",] %>% as.vector() %>% t()
tissueTool$CDH1_Level <- ifelse(tissueTool$CDH1_Expression > quantile(tissueTool$CDH1_Expression , 0.3), "High", "Low")

# Create "GeneLabelTool", for matching gene ID's in different formats.
GeneLabelTool <- strsplit(rownames(expDatRaw), '\\.') %>% 
  lapply(., function(x) x[1]) %>% 
  unlist()
GeneLabelTool <- AnnotationDbi::select(hs,
                                       keys = GeneLabelTool,
                                       columns = c("ENSEMBL", "ENTREZID", "SYMBOL"),
                                       keytype = "ENSEMBL")

GeneLabelTool <- na.omit(GeneLabelTool)
```

## Carry out the Primary Analyses
### Apply Dasatinib Based Transformation to all Drugs and Cell Lines, Using Matrix Multiplication
```{r}
# Proccess "expDatAll" so it's in the same format as "expDat_Dasatinib".
expDatAll <- expDatRaw
colnames(expDatAll) <- strsplit(colnames(expDatAll), "_") %>% 
  lapply(., function(x) x[1]) %>% 
  unlist()
rownames(expDatAll) <- strsplit(rownames(expDatAll), '\\.') %>% 
  lapply(., function(x) x[1]) %>% 
  unlist()

# Cut "expDatAll" down to just the genes that have data for all name formats and expression.
expDatAll <- subset(expDatAll, rownames(expDatAll) %in% GeneLabelTool$ENSEMBL)
# Remove any duplicate rows
expDatAll <- expDatAll[!duplicated(rownames(expDatAll)), ]
# Swap ENSEMBL ID's for Symbol ID's.
rownames(expDatAll) <- match(rownames(expDatAll), GeneLabelTool$ENSEMBL) %>% 
  GeneLabelTool$SYMBOL[.]

# Create "pathMatX", from dasatinib data in breast and stomach cell lines, to be used to weight the rest of the data.
pathMatX <- matrix(data = 0, length(ensginPaths), ncol(expDat_Dasatinib))
rownames(pathMatX) <- goseqPathways$Pathway
colnames(pathMatX) <- colnames(expDat_Dasatinib)

# Create "pathMatY", the rest of the data which will be weighted by "PathMatX".
pathMatY <- matrix(data = 0, length(ensginPaths), ncol(expDatAll))
rownames(pathMatY) <- goseqPathways$Pathway
colnames(pathMatY) <- colnames(expDatAll)

```

### Create and Apply the Transformation Matrix
```{r}
# Carry out matrix multiplication to transform "PathMatY".
for(j in 1:length(ensginPaths)){
  # Create "xx".
  pathway_expDat_Dasatinib <- subset(expDat_Dasatinib, rownames(expDat_Dasatinib) %in% ensginPaths[[j]])
  pathway_expDat_Dasatinib <- subset(pathway_expDat_Dasatinib, rownames(pathway_expDat_Dasatinib) %in% GeneLabelTool$ENSEMBL)
  rownames(pathway_expDat_Dasatinib) <- match(rownames(pathway_expDat_Dasatinib), GeneLabelTool$ENSEMBL) %>% 
    GeneLabelTool$SYMBOL[.]
  xx <- apply(pathway_expDat_Dasatinib, 1, scale, scale = TRUE) %>% t()
  colnames(xx) <- colnames(pathway_expDat_Dasatinib)
  
  # Create the pathway/metagene matrix, doesn't really work for metagenes with so few genes involved, so they are discounted.
  if(nrow(xx)>4){
    
    # Subset "expDatAll" so it only contains the genes found in "xx".
    expDatAllY <- subset(expDatAll, rownames(expDatAll) %in% rownames(xx))
    expDatAllYNames <- expDatAllY
    expDatAllY <- apply(expDatAllY, 1, scale, scale = TRUE) %>% t()
    colnames(expDatAllY) <- colnames(expDatAllYNames)
    # Remove Duplicates
    expDatAllY <- expDatAllY[!duplicated(rownames(expDatAllY)), ]
    
    # Subset "xx" so it only contains the genes also found in "expDatAllY".
    xx <- subset(xx, rownames(xx) %in% rownames(expDatAllY))
    
    # Create the metagene.
    sX <- svd(xx)
    mgX <- sX$v[ ,1]
    # Add the metagenes to the matrix of pathways vs metagenes.
    pathMatX[j, ] <- mgX
    
    # Create the transformation matrix.
    tr <- diag(1/sX$d) %*% t(sX$u)
    # Create the metagene, using the transformation matrix.
    mgY <- (t(expDatAllY) %*% t(tr))[ ,1]
    # Add the metagenes to the matrix of pathways vs metagenes, "pathMatY".
    pathMatY[j, ] <- mgY
  }
}  

# Remove any duplicate columns from the pathway matrix.
pathMatY <- pathMatY[, !duplicated(colnames(pathMatY))]
```


### Create a Matrix of Drug by Sample for Area Under the Curve (AUC) Data
```{r}
# Ensure that no drugs or cell lines have multiple entries.
AUCSamplesY <- matrix(0,length(unique(GDSC2$DRUG_NAME)), length(unique(GDSC2$CELL_LINE_NAME)))
rownames(AUCSamplesY) <- unique(GDSC2$DRUG_NAME)
colnames(AUCSamplesY) <- unique(GDSC2$CELL_LINE_NAME)

# Loop through data to create the matrix.
for(i in 1:nrow(AUCSamplesY)){
  for(j in 1:ncol(AUCSamplesY)){
    y <- GDSC2$AUC[which(rownames(AUCSamplesY)[i] == GDSC2$DRUG_NAME & colnames(AUCSamplesY)[j] == GDSC2$CELL_LINE_NAME)]
    ifelse(length(y) != 0,
           AUCSamplesY[i,j] <- y[1],
           AUCSamplesY[i,j] <- 0
    )
  }
}
```

## Analyse the Drug by Pathway Correlations

### Setup Heatmaps with Data from all Cell Lines
```{r, warning = FALSE}
# Subset "AUCSamplesY" so it only includes cell lines that are present in "pathMatY", and vice versa.
AUCSamplesSubsetY <- select_if(as.data.frame(AUCSamplesY), colnames(AUCSamplesY) %in% colnames(pathMatY)) %>% 
  as.matrix(.)
pathMatSubsetY <- select_if(as.data.frame(pathMatY), colnames(pathMatY) %in% colnames(AUCSamplesSubsetY)) %>% 
  as.matrix(.)
# AUCSamplesSubsetY <- subset(AUCSamplesSubsetY, colnames(AUCSamplesSubsetY) %in% colnames(pathMatSubsetY))

# Order the columns of each table in the same manner.
oo <- match(colnames(AUCSamplesSubsetY), colnames(pathMatSubsetY))
pathMatSubsetY <- pathMatSubsetY[,oo]

# Create a drug by pathway correlation matrix.
drugMetageneCorY <- cor(t(pathMatSubsetY), t(AUCSamplesSubsetY), method = "spearman") %>% na.omit(.)
write.csv(drugMetageneCorY, file = "Dasatinib_Metagenes_Output/Other/Drug_Metagene_Correlations.csv", sep = ",", row.names = TRUE, col.names = TRUE)
```

### Check the Correlations, and Determine a Threshold for Significant Interactions
```{r}
# How many drug/pathway interactions satisfy a given cutoff? This will be reflected in the number of heatmaps created.
for(i in seq(0.1, 1.0, by = 0.1)){
  sum(abs(drugMetageneCorY)>i) %>% print()
}

# Determine the correlation threshold used throughout the rest of this document
cor.thresh <- 0.4

# Which rows have the most of these values, and more than 0?
PathDrugsNo <- rowSums(abs(drugMetageneCorY)>cor.thresh) %>% .[.>0] %>% sort(., decreasing = TRUE) %>% as.data.frame(.)
colnames(PathDrugsNo) <- "No. of Strongly Associated Drugs"
kable(PathDrugsNo) %>% kable_styling(bootstrap_options = c("striped", "condensed", font_size=8), fixed_thead=T) %>% save_kable("Dasatinib_Metagenes_Output/Other/PathDrugsNo.png")
# Which columns have the most of these values, and more than 0?
DrugPathsNo <- colSums(abs(drugMetageneCorY)>cor.thresh) %>% .[.>0] %>% sort(., decreasing = TRUE) %>% as.data.frame(.)
colnames(DrugPathsNo) <- "No. of Strongly Associated Reactome Pathways"
kable(DrugPathsNo) %>% kable_styling(bootstrap_options = c("striped", "condensed", font_size=8), fixed_thead=T) %>% save_kable("Dasatinib_Metagenes_Output/Other/DrugPathsNo.png")
# Create a new matrix, replacing every value which isn't greater than abs(cor.thresh) with an NA, to make it more clear which correlations are interesting.
SigDMCorY <- drugMetageneCorY
SigDMCorY[abs(SigDMCorY)<cor.thresh] <- NA

# Make the loop only work on strong correlations (>cor.thresh) between a drug and a pathway.
SigPaths <- rowSums(abs(drugMetageneCorY)>cor.thresh) %>% sort(., decreasing = TRUE) %>% .[.>0]
```

### Create Heatmaps for Pathway Metagenes
```{r, warning = FALSE, message = FALSE}
for(p in 1:nrow(pathMatY)){
  # Define which pathway is being worked on.
  pathname <- rownames(pathMatY)[p]
  pn <- gsub(" ", "_", pathname)
  # Create "xx".
  pathway_expDat_Dasatinib <- subset(expDat_Dasatinib, rownames(expDat_Dasatinib) %in% ensginPaths[[p]])
  pathway_expDat_Dasatinib <- subset(pathway_expDat_Dasatinib, rownames(pathway_expDat_Dasatinib) %in% GeneLabelTool$ENSEMBL)
  # Convert Symbol ID's to ENSEMBL ID's.
  rownames(pathway_expDat_Dasatinib) <- match(rownames(pathway_expDat_Dasatinib), GeneLabelTool$ENSEMBL) %>% 
    GeneLabelTool$SYMBOL[.]
  
  xx <- apply(pathway_expDat_Dasatinib, 1, scale, scale = TRUE) %>% t()
  colnames(xx) <- colnames(pathway_expDat_Dasatinib)
  
  if(rownames(pathMatY)[p] %in% names(SigPaths)){
    # Subset "expDatAll" so it only contains the genes found in "xx".
    expDatAllY <- subset(expDatAll, rownames(expDatAll) %in% rownames(xx))
    # Cut down on extreme values and scales the data.
    yy <- apply(expDatAllY, 1, scale, scale = TRUE) %>% t()
    colnames(yy) <- colnames(expDatAllY)
    yy[yy > 3] <- 3
    yy[yy < -3] <- -3
    
    ## Create an object that shows which drugs are significant, and is re-created for each pathway.
    aa <- subset(drugMetageneCorY, rownames(drugMetageneCorY) == pathname)
    SigDrugs <- colSums(abs(aa)>cor.thresh) %>% sort(., decreasing = TRUE) %>% .[.>0]
    
    for(q in 1:length(SigDrugs)){
      # Loop through the drugs involved with this pathway, and finds an AUC for each.
      drugname <- names(SigDrugs)[q]
      dn <- gsub(" ", "_", drugname)
      drugAUC <- subset(AUCSamplesSubsetY, rownames(AUCSamplesSubsetY) == drugname)
      # Create a matrix/row to order cell lines by AUC.
      expressioncols <- matrix((as.factor(drugAUC) %>% as.numeric() %>% cividis(length(table(.)), direction = 1)[.]), nrow = 1)
      rownames(expressioncols) <- ""
      # Make R and heatmap.mik behave better.
      white <- matrix(rep("white") , nrow = 1, ncol = ncol(expressioncols))
      rownames(white) <- ""
      cc <- rbind(white, expressioncols)
      # Order the columns by AUC for the given drug.
      colord <- order(drugAUC)
      # Create heatmaps and save them as pngs.
      png(paste0("Dasatinib_Metagenes_Output/Metagene_Heatmaps/", pn, "_", dn, "_heatmap.png"), width = 2000, height = 2000)
      heatmap.mik(yy[ , colord],
                  trace = 'none',
                  scale = 'none',
                  col = bluered(50),
                  ColSideColors = cc[ , colord],
                  Colv = FALSE,
                  mar = c(4,12),
                  keysize = 1, cexRow = 32/nrow(yy)
      )
      # Add an AUC legend and larger title.
      legend(x = 0.5, y = 0.9, legend = c("High AUC", "Low AUC"), fill = c("#FFEA46FF", "#00204DFF"), cex = 3)
      title(paste(pathname, "-", drugname), cex.main = 3)
      dev.off()
    }
  }  
}
```

### Investigate Which Pathways Cluster Together
* This uses all pathways from goseq with adj-p-value < 1 (not just the ones statistically significant from goseq or gsea), but only clusters the ones with a correlation above the threshold
```{r, message = FALSE, warning = FALSE}
# Create a list of the genes in each significant pathway.
names(ensginPaths) <- goseqPathways$Pathway
# Because we here filter by SigPaths, we're only clustering the overlap between pathways that are targeted by drugs, as we don't really care that much about the others. However, as a result, we also only create metapathways out of those pathways that are being targeted by any drugs - this means we have signatures that represent processes that are specifically being targeted, not just all the processes altered in dasatinib-resistant cells.
ensginSigPaths <- subset(ensginPaths, names(ensginPaths) %in% names(SigPaths))

# Create a loop that creates a matrix of this information.
PathGeneInt <- matrix(data = 0, nrow = length(ensginSigPaths), ncol = length(ensginSigPaths))
rownames(PathGeneInt) <- colnames(PathGeneInt) <- names(ensginSigPaths)
for(i in 1:length(ensginSigPaths)){
  for(j in 1:length(ensginSigPaths)){
    Pathi <- ensginSigPaths[[i]]
    Pathj <- ensginSigPaths[[j]]
    PathGeneInt[i,j] <- length(intersect(Pathi, Pathj)) / length(Pathi)
  }
}

# This works for now, but will need to be replaced/updated so it's not hard-coded in. Replaced for plotting purposes
colnames(PathGeneInt)[10] <- "Regulation of IGF transport and uptake by IGFBPs"
rownames(PathGeneInt)[10] <- "Regulation of IGF transport and uptake by IGFBPs"

# Plot the matrix.
cols <- colorRampPalette(c("white", "#F8766D"))(n = 50)
ord <- as.dendrogram(hclust(dist(PathGeneInt)))
png("Dasatinib_Metagenes_Output/Other/Pathway_Overlap.png", width = 204.92, height = 204.92, units = "mm", res = 600)
par(cex.main = 1.2, cex.lab = 1, cex.axis = 1, family = "Times New Roman")
heatmap.2(PathGeneInt, scale = 'none', trace = 'none', col = cols,
          key = T,
          keysize = 1, density.info = "none",
          mar = c(2,2), # cexRow = 3, cexCol = 3, cex.main = 10,
          dendrogram = 'row',
          main = "Pathway Overlap in Genes",
          xlab = "Dasatinib-Associated Pathways", ylab = "Dasatinib-Associated Pathways",
          key.ylab = NA, key.xlab = "Proportion of\nShared Genes",
          key.xtickfun = function() {
            # Custom function to set ticks at 0, 0.5, and 1 on the color key
            axis(side = 1, at = c(0, 0.5, 1), labels = c("0", "0.5", "1"))
          },
          Rowv = ord, Colv = ord,
          labRow = NA, labCol = NA)
dev.off()
```

## Create MetaPathways
### Cluster "MetaPathways" (Pathways That Have Similar Compositions)
```{r}
# Cluster the data based on the first axis.
xdist <- as.dist(1-cor(PathGeneInt)) %>% hclust(.) %>% cutree(., 4)

# Create 4 metapathways, using the xdist measure, then remove genes that aren't in more than one of the pathways within a MetaPathway
MPath1 <- names(xdist)[xdist == 1]
MPath1Genes <- ensginSigPaths[match(MPath1, names(ensginSigPaths))] %>% unlist(.) %>% table(.) %>% sort(.)
MPath1Genes <- MPath1Genes[MPath1Genes != 1]

MPath2 <- names(xdist)[xdist == 2]
MPath2Genes <- ensginSigPaths[match(MPath2, names(ensginSigPaths))] %>% unlist(.) %>% table(.) %>% sort(.)
MPath2Genes <- MPath2Genes[MPath2Genes != 1]

MPath3 <- names(xdist)[xdist == 3]
MPath3Genes <- ensginSigPaths[match(MPath3, names(ensginSigPaths))] %>% unlist(.) %>% table(.) %>% sort(.)
MPath3Genes <- MPath3Genes[MPath3Genes != 1]

MPath4 <- names(xdist)[xdist == 4]
MPath4Genes <- ensginSigPaths[match(MPath4, names(ensginSigPaths))] %>% unlist(.) %>% table(.) %>% sort(.)
MPath4Genes <- MPath4Genes[MPath4Genes != 1]

MetaPathways <- list(MetaPathway1 = names(MPath1Genes), MetaPathway2 = names(MPath2Genes), MetaPathway3 = names(MPath3Genes), MetaPathway4 = names(MPath4Genes))
MetaPathwayContents <- list(MetaPathway1 = MPath1, MetaPathway2 = MPath2, MetaPathway3 = MPath3, MetaPathway4 = MPath4)

# Create a filtered version of MetaPathwayContents
filtered_MetaPathwayContents <- lapply(seq_along(MetaPathways), function(i) {
  # Get the current gene list and pathway list
  genes <- MetaPathways[[i]]
  pathways <- MetaPathwayContents[[i]]
  
  # Filter the pathways
  filtered_pathways <- pathways[sapply(pathways, function(pathway) {
    # Check if any gene from MetaPathways[[i]] exists in the gene list of this pathway in ensginSigPaths
    any(genes %in% ensginSigPaths[[pathway]])
  })]
  
  return(filtered_pathways)  # Return the filtered pathway names
})

# 'filtered_MetaPathwayContents' now contains only pathways with matching genes from MetaPathways.
# Print for summary table in thesis

# Loop through each character vector in MetaPathwayContents
filtered_MetaPathwayContents <- lapply(filtered_MetaPathwayContents, function(pathways) {
  
  # For each pathway term in the vector, check its adjP in goseqPathways and add the significance marker
  sapply(pathways, function(pathway) {
    # Find the row in goseqPathways that matches the current pathway term
    adjP_value <- goseqPathways$adjP[goseqPathways$Pathway == pathway]
    
    # Add the significance marker based on the adjP value
    if (length(adjP_value) > 0) {  # Check if the pathway term was found in goseqPathways
      if (adjP_value < 0.001) {
        paste0(pathway, " (***)")
      } else if (adjP_value < 0.01) {
        paste0(pathway, " (**)")
      } else if (adjP_value < 0.05) {
        paste0(pathway, " (*)")
      } else {
        paste0(pathway, " (NS)")
      }
    } else {
      pathway  # If no matching adjP value is found, leave the pathway term unchanged
    }
  })
})

# Convert the list back to its original structure, if necessary
filtered_MetaPathwayContents <- lapply(filtered_MetaPathwayContents, as.character)
names(filtered_MetaPathwayContents) <- names(MetaPathwayContents)

# Use lapply to print each element of filtered_MetaPathwayContents
lapply(seq_along(filtered_MetaPathwayContents), function(i) {
  cat("Element", i, ":\n")  # Print the element number
  cat(filtered_MetaPathwayContents[[i]], sep = ", ")  # Print the contents, separated by commas
  cat("\n\n")  # Add an extra newline for readability between elements
})
```

```{r, echo = FALSE, message = FALSE, warning = FALSE, results = "hide"}
# Now do the same but to find gene lists (symbol IDs) per metapathway.
# Load necessary packages
library(AnnotationDbi)
library(org.Hs.eg.db)

# Function to convert ENSEMBL IDs to gene symbols, handle duplicates, and sort alphabetically
convert_ensembl_to_symbol <- function(ensembl_ids) {
  # Use AnnotationDbi::select to map ENSEMBL IDs to gene symbols
  result <- AnnotationDbi::select(org.Hs.eg.db, 
                                  keys = ensembl_ids, 
                                  columns = "SYMBOL", 
                                  keytype = "ENSEMBL")
  
  # Remove duplicates to handle 1:many mappings by keeping unique pairs
  unique_result <- result[!duplicated(result$ENSEMBL), ]
  
  # Extract the mapped symbols and unmapped IDs
  mapped_symbols <- unique_result$SYMBOL
  mapped_ensembl <- unique_result$ENSEMBL
  
  # Find ENSEMBL IDs that didn't map to any gene symbol
  unmapped_ensembl <- setdiff(ensembl_ids, mapped_ensembl)
  
  # Combine mapped symbols and unmapped IDs into a single vector, remove duplicates, and sort alphabetically
  sorted_unique_results <- sort(unique(c(mapped_symbols, unmapped_ensembl)))
  
  return(sorted_unique_results)
}

# Apply the function to each element of MetaPathways and store in a new list
conversion_results <- lapply(MetaPathways, function(ensembl_ids) {
  convert_ensembl_to_symbol(ensembl_ids)
})

# 'conversion_results' now contains a list where each element is a sorted, deduplicated vector
# of mapped gene symbols and unmapped ENSEMBL IDs for each element in 'MetaPathways'.
```

### Create New Metagenes, for Each MetaPathway
```{r}
# 'M.' denotes that these objects relate to a MetaPathway.
# Create "M.pathMatX", from dasatinib data in breast and stomach cell lines, to be used to weight the rest of the data.
M.pathMatX <- matrix(data = 0, length(MetaPathways), ncol(expDat_Dasatinib))
rownames(M.pathMatX) <- names(MetaPathways)
colnames(M.pathMatX) <- colnames(expDat_Dasatinib)
# Create "M.pathMatY", the rest of the data which will be weighted by "M.PathMatX".
M.pathMatY <- matrix(data = 0, length(MetaPathways), ncol(expDatAll))
rownames(M.pathMatY) <- names(MetaPathways)
colnames(M.pathMatY) <- colnames(expDatAll)

for(j in 1:length(MetaPathways)){
  # Create "M.xx"
  M.pathway_expDat_Dasatinib <- subset(expDat_Dasatinib, rownames(expDat_Dasatinib) %in% MetaPathways[[j]])
  rownames(M.pathway_expDat_Dasatinib) <- match(rownames(M.pathway_expDat_Dasatinib), GeneLabelTool$ENSEMBL) %>%
    GeneLabelTool$SYMBOL[.]
  M.xx <- apply(M.pathway_expDat_Dasatinib, 1, scale, scale = TRUE) %>% t()
  colnames(M.xx) <- colnames(M.pathway_expDat_Dasatinib)
  # Create the metagene/pathway matrix.
  if(nrow(M.xx)>4){
    
    # Subset "M.expDatAll" so it only contains the genes found in "M.xx".
    M.expDatAllY <- subset(expDatAll, rownames(expDatAll) %in% rownames(M.xx))
    M.expDatAllYNames <- M.expDatAllY
    M.expDatAllY <- apply(M.expDatAllY, 1, scale, scale = TRUE) %>% t()
    colnames(M.expDatAllY) <- colnames(M.expDatAllYNames)
    # Remove Duplicates
    M.expDatAllY <- M.expDatAllY[!duplicated(rownames(M.expDatAllY)), ]
    
    # Subset "xx" so it only contains the genes also found in "expDatAllY".
    M.xx <- subset(M.xx, rownames(M.xx) %in% rownames(M.expDatAllY))
    
    # Create the metagene.
    M.sX <- svd(M.xx)
    M.mgX <- M.sX$v[ ,1]
    # Add the metagenes to the matrix of pathways vs metagenes.
    M.pathMatX[j, ] <- M.mgX
    
    # Create the transformation matrix.
    M.tr <- diag(1/M.sX$d) %*% t(M.sX$u)
    # Create the metagene, using the transformation matrix.
    M.mgY <- (t(M.expDatAllY) %*% t(M.tr))[ ,1]
    # Add the MetaPathway values to the matrix of pathways vs metagenes.
    M.pathMatY[j, ] <- M.mgY
  }
}

# Remove any duplicate columns from the pathway matrix.
M.pathMatY <- M.pathMatY[, !duplicated(colnames(M.pathMatY))]
```

### Find Correlations
```{r}
# Subset "M.AUCSamplesY" so it only includes cell lines that are present in "M.pathMatY", and vice versa.
M.AUCSamplesSubsetY <- select_if(as.data.frame(AUCSamplesY), colnames(AUCSamplesY) %in% colnames(M.pathMatY)) %>% 
  as.matrix(.)
M.pathMatSubsetY <- select_if(as.data.frame(M.pathMatY), colnames(M.pathMatY) %in% colnames(M.AUCSamplesSubsetY)) %>% 
  as.matrix(.)

# Order the columns of each table in the same manner.
M.oo <- match(colnames(M.AUCSamplesSubsetY), colnames(M.pathMatSubsetY))
M.pathMatSubsetY <- M.pathMatSubsetY[,M.oo]

# Create a drug by MetaPathway correlation matrix.
M.drugMetageneCorY <- cor(t(M.pathMatSubsetY), t(M.AUCSamplesSubsetY), method = "spearman") %>% na.omit(.)
write.csv(M.drugMetageneCorY, file = "Dasatinib_Metagenes_Output/Other/Drug_Metapathway_Correlations.csv", sep = ",", row.names = TRUE, col.names = TRUE)

# How many drug/metapathway correlations satisfy a given threshold?
for(i in seq(0.1, 1.0, by = 0.1)){
  sum(abs(M.drugMetageneCorY)>i) %>% print()
}

M.cor.thresh <-  0.4

# Print the values that are above the threshold
# Loop through each row of the data frame
for (i in seq_len(nrow(M.drugMetageneCorY))) {
  # Get the row name
  row_name <- rownames(M.drugMetageneCorY)[i]
  
  # Find columns in the current row where the absolute value is greater than 0.4
  cols_with_high_values <- which(abs(M.drugMetageneCorY[i, ]) > 0.4)
  
  # If any such columns exist, print the row name and the corresponding column names with values
  if (length(cols_with_high_values) > 0) {
    # Sort the columns alphabetically by their names
    sorted_cols <- sort(colnames(M.drugMetageneCorY)[cols_with_high_values])
    
    # Print the row name
    cat(row_name, ": ")
    
    # For each sorted column, print in the format "column name (value)", rounding to 3 decimal places
    cat(paste(sorted_cols, 
              "(", round(M.drugMetageneCorY[i, sorted_cols], 3), ")", 
              sep = "", collapse = ", "))
    
    # Print a newline for better readability between rows
    cat("\n")
  }
}

# Initialize the list to store results
metapathway_drug_associations <- list()

# Loop through each row of M.drugMetageneCorY
for (i in seq_len(nrow(M.drugMetageneCorY))) {
  # Get the row name
  row_name <- rownames(M.drugMetageneCorY)[i]
  
  # Find columns in the current row where the absolute value is greater than 0.4
  cols_with_high_values <- which(abs(M.drugMetageneCorY[i, ]) > 0.4)
  
  # If any such columns exist, save the results
  if (length(cols_with_high_values) > 0) {
    # Sort the columns alphabetically by their names
    sorted_cols <- sort(colnames(M.drugMetageneCorY)[cols_with_high_values])
    
    # Create a character vector to store the associations for this row
    associations <- paste(sorted_cols, 
                          " (", round(M.drugMetageneCorY[i, sorted_cols], 3), ")", 
                          sep = "")
    
    # Save the associations in the list under the row name
    metapathway_drug_associations[[row_name]] <- associations
  }
}
```


### Compare Metapathways to Drugs - as PNGs
```{r, warning = FALSE}
# Plot drugs by MetaPathways (as opposed to drugs by pathways), to improve the analysis.
for(p in 1:length(MetaPathways)){
  # Define which pathway is being worked on.
  mpathname <- names(MetaPathways)[p]
  mpn <- gsub(" ", "_", mpathname)
  
  # Create "M.yy".
  
  # Copy "expDatAll".
  M.expDatAllY <- expDatAll
  # Convert rownames from Symbol ID's to ENSEMBL ID's to find them in MetaPathways.
  rownames(M.expDatAllY) <- match(rownames(M.expDatAllY), GeneLabelTool$SYMBOL) %>% GeneLabelTool$ENSEMBL[.]
  # Find them in MetaPathways.
  M.expDatAllY <- subset(M.expDatAllY, rownames(M.expDatAllY) %in% MetaPathways[[p]])
  # Convert back to Symbol ID's.
  rownames(M.expDatAllY) <- match(rownames(M.expDatAllY), GeneLabelTool$ENSEMBL) %>% GeneLabelTool$SYMBOL[.]
  # Cut down on extreme values and scale the data.
  M.yy <- apply(M.expDatAllY, 1, scale, scale = TRUE) %>% t()
  colnames(M.yy) <- colnames(M.expDatAllY)
  M.yy[M.yy > 3] <- 3
  M.yy[M.yy < -3] <- -3
  
  # Create an object that notes which drugs are significant, and is re-created for each pathway.
  M.aa <- subset(M.drugMetageneCorY, rownames(M.drugMetageneCorY) == mpathname)
  M.SigDrugs <- colSums(abs(M.aa)>M.cor.thresh) %>% sort(., decreasing = TRUE) %>% .[.>0]
  
  for(q in 1:length(M.SigDrugs)){
    if(length(M.SigDrugs > 0)){
      
      # Loop through the drugs involved with this pathway, and find an AUC for each.
      mdrugname <- names(M.SigDrugs)[q]
      mdn <- gsub(" ", "_", mdrugname)
      M.drugAUC <- subset(M.AUCSamplesSubsetY, rownames(M.AUCSamplesSubsetY) == mdrugname)
      # Create a colour strip for AUC values.
      M.expressioncols <- matrix((as.factor(M.drugAUC) %>% as.numeric() %>%
                                    cividis(length(table(.)), direction = 1)[.]), nrow = 1)
      rownames(M.expressioncols) <- "AUC"
      # light is currently attached to high AUC, but not in legend
      # Create a vector of cell lines that have AUC data.
      M.cell.lines <- intersect(colnames(M.drugAUC), colnames(M.pathMatY))
      
      # Create a matrix for the current MetaPathway value.
      M.MetaPathwayValue <- M.pathMatY[p, M.cell.lines] %>% as.matrix(.) %>% t(.)
      rownames(M.MetaPathwayValue) <- rownames(M.pathMatY)[p]
      # Create a colour strip for the MetaPathway values.
      M.MetaPathwaycols <- matrix((as.factor(M.MetaPathwayValue) %>%
                                     as.numeric() %>% plasma(length(table(.)), direction = 1)[.]), nrow = nrow(M.MetaPathwayValue))
      rownames(M.MetaPathwaycols) <- paste0(rownames(M.MetaPathwayValue), " Metagene Value")
      
      # Create a matrix for metagene values (each representing a pathway) within the MetaPathway.
      M.PathX <- intersect(rownames(pathMatY), MetaPathwayContents[[p]])
      # Cut this down so only the cell lines that have drug data are included.
      M.MetaPathwayContentsValue <- pathMatY[M.PathX, M.cell.lines]
      # Create a set of colour strips for metagene values (representing pathways).
      M.MetaPathwayContentscols <- matrix((as.factor(M.MetaPathwayContentsValue) %>%
                                             as.numeric() %>% inferno(length(table(.)), direction = 1)[.]), nrow = nrow(M.MetaPathwayContentsValue))
      rownames(M.MetaPathwayContentscols) <- rownames(M.MetaPathwayContentsValue)
      
      # Add CDH1 expression data.
      M.CDH1Expression <- tissueTool$CDH1_Expression[M.cell.lines, ] %>% as.matrix(.) %>% t(.)
      rownames(M.CDH1Expression) <- "CDH1 Expression"
      # Add a CDH1 expression data colour strip.
      M.CDH1Expressioncols <- matrix((as.factor(M.CDH1Expression) %>% 
                                        as.numeric() %>% plasma(length(table(.)), direction = 1)[.]), nrow = nrow(M.CDH1Expression))
      rownames(M.CDH1Expressioncols) <- rownames(M.CDH1Expression)
      # Add CDH1 expression level.
      M.CDH1Level <- tissueTool$CDH1_Level[M.cell.lines, ] %>% as.matrix(.) %>% t(.)
      rownames(M.CDH1Level) <- "CDH1 Expression Level"
      # Add a CDH1 expression level colour strip.
      M.CDH1Levelcols <- matrix((as.factor(M.CDH1Level) %>% 
                                   as.numeric() %>% plasma(length(table(.)), direction = -1)[.]), nrow = nrow(M.CDH1Level))
      rownames(M.CDH1Levelcols) <- rownames(M.CDH1Level)
      
      # Combine each of the colour strips/matrices.
      M.cc <- rbind(M.MetaPathwayContentscols, M.CDH1Expressioncols, M.CDH1Levelcols, M.MetaPathwaycols, M.expressioncols)
      colnames(M.cc) <- M.cell.lines
      # Order by AUC.
      # M.colord <- order(M.drugAUC)
      # Order by MetaPathway value.
      M.colord <- order(M.MetaPathwayValue)
      
      # Ensure that the cell lines (columns) in "M.yy" are the same as the cell lines used to create the MetaPathway.
      M.yy <- M.yy[ , match(colnames(M.MetaPathwayValue), colnames(M.yy))]
      
      # Create heatmaps and save them as pngs.
      png(paste0("Dasatinib_Metagenes_Output/Metapathway_Heatmaps/", mpn, "_", mdn, "_heatmap.png"), width = 5000, height = 4000)
      par(cex.axis = 4, cex.lab = 4, cex.main = 3)
      heatmap.mik(M.yy[ , M.colord],
                  trace = 'none',
                  scale = 'none',
                  col = bluered(50),
                  ColSideColors = M.cc[ , M.colord],
                  Colv = FALSE,
                  mar = c(10,200),
                  keysize = 1,
                  cexCol = 8, cexRow = 32/nrow(M.yy),
                  labCol = "", labRow = ""
      )
      # Add an AUC and CHD1 expression legend and larger title.
      legend(x = 0.32, y = 0.97, legend = c("High AUC", "High CDH1 Expression", "High Metapathway Value", "Low AUC", "Low CDH1 Expression", "Low Metapathway Value"), fill = c("#FFEA46FF", "#F0F921FF", "#F0F921FF", "#00204DFF", "#0D0887FF", "#0D0887FF"), cex = 5, ncol = 2)
      title(paste(mpathname, "-", mdrugname), cex.main = 5)
      dev.off()
    }
  }
}
```

### Compare Metapathways to Drugs - as PNGs for thesis with a different layout
```{r, warning = FALSE}
# Plot drugs by MetaPathways (as opposed to drugs by pathways), to improve the analysis.
for(p in 1:length(MetaPathways)){
  # Define which pathway is being worked on.
  mpathname <- names(MetaPathways)[p]
  mpn <- gsub(" ", "_", mpathname)
  mpathname_title <- sub("MetaPathway([0-9]+)", "Metapathway \\1", mpathname)
  
  # Create "M.yy".
  
  # Copy "expDatAll".
  M.expDatAllY <- expDatAll
  # Convert rownames from Symbol ID's to ENSEMBL ID's to find them in MetaPathways.
  rownames(M.expDatAllY) <- match(rownames(M.expDatAllY), GeneLabelTool$SYMBOL) %>% GeneLabelTool$ENSEMBL[.]
  # Find them in MetaPathways.
  M.expDatAllY <- subset(M.expDatAllY, rownames(M.expDatAllY) %in% MetaPathways[[p]])
  # Convert back to Symbol ID's.
  rownames(M.expDatAllY) <- match(rownames(M.expDatAllY), GeneLabelTool$ENSEMBL) %>% GeneLabelTool$SYMBOL[.]
  # Cut down on extreme values and scale the data.
  M.yy <- apply(M.expDatAllY, 1, scale, scale = TRUE) %>% t()
  colnames(M.yy) <- colnames(M.expDatAllY)
  M.yy[M.yy > 3] <- 3
  M.yy[M.yy < -3] <- -3
  
  # Create an object that notes which drugs are significant, and is re-created for each pathway.
  M.aa <- subset(M.drugMetageneCorY, rownames(M.drugMetageneCorY) == mpathname)
  M.SigDrugs <- colSums(abs(M.aa)>M.cor.thresh) %>% sort(., decreasing = TRUE) %>% .[.>0]
  
  # Create a few new objects which need to be lists now to account for multiple drugs in one heatmap
  M.drugAUC <- list()
  M.expressioncols <- list()
  
  for(q in 1:length(M.SigDrugs)){
    if(length(M.SigDrugs > 0)){
      
      # Loop through the drugs involved with this pathway, and find an AUC for each.
      mdrugname <- names(M.SigDrugs)[q]
      M.drugAUC[[q]] <- subset(M.AUCSamplesSubsetY, rownames(M.AUCSamplesSubsetY) == mdrugname)
      names(M.drugAUC)[q] <- gsub(" ", "_", mdrugname)
      # Create a colour strip for AUC values.
      M.expressioncols[[q]] <- matrix((as.factor(M.drugAUC[[q]]) %>% as.numeric() %>%
                                         cividis(length(table(.)), direction = 1)[.]) , nrow = 1)
      names(M.expressioncols)[q] <- paste0(gsub(" ", "_", mdrugname), " AUC")
      rownames(M.expressioncols[[q]]) <- paste0(gsub(" ", "_", mdrugname), " AUC")
      colnames(M.expressioncols[[q]]) <- colnames(M.drugAUC[[q]])
      # Create a vector of cell lines that have AUC data.
      M.cell.lines <- intersect(colnames(M.drugAUC[[q]]), colnames(M.pathMatY))
      # Loop should end here as this should have created the matrix you need for drug AUC
    }
  }
  # Convert into a data.frame
  M.expressioncols2 <- do.call(rbind, M.expressioncols)
  M.expressioncols2 <- M.expressioncols2[order(rownames(M.expressioncols2)), ]
  # Create a matrix for the current MetaPathway value
  M.MetaPathwayValue <- M.pathMatY[p, M.cell.lines] %>% as.matrix(.) %>% t(.)
  rownames(M.MetaPathwayValue) <- rownames(M.pathMatY)[p]
  # Create a colour strip for the MetaPathway values.
  M.MetaPathwaycols <- matrix((as.factor(M.MetaPathwayValue) %>%
                                 as.numeric() %>% plasma(length(table(.)), direction = 1)[.]), nrow = nrow(M.MetaPathwayValue))
  rownames(M.MetaPathwaycols) <- paste0(rownames(M.MetaPathwayValue), " Metagene Value")
  colnames(M.MetaPathwaycols) <- colnames(M.MetaPathwayValue)
  # Add CDH1 expression data.
  M.CDH1Expression <- tissueTool$CDH1_Expression[M.cell.lines, ] %>% as.matrix(.) %>% t(.)
  rownames(M.CDH1Expression) <- "CDH1 Expression"
  # Add a CDH1 expression data colour strip.
  M.CDH1Expressioncols <- matrix((as.factor(M.CDH1Expression) %>% 
                                    as.numeric() %>% plasma(length(table(.)), direction = 1)[.]), nrow = nrow(M.CDH1Expression))
  rownames(M.CDH1Expressioncols) <- rownames(M.CDH1Expression)
  colnames(M.CDH1Expressioncols) <- colnames(M.CDH1Expression)
  # Add CDH1 expression level.
  M.CDH1Level <- tissueTool$CDH1_Level[M.cell.lines, ] %>% as.matrix(.) %>% t(.)
  rownames(M.CDH1Level) <- "CDH1 Expression Level"
  
  # Combine each of the colour strips/matrices.
  M.cc <- rbind(M.expressioncols2, M.CDH1Expressioncols, M.MetaPathwaycols)
  
  colnames(M.cc) <- M.cell.lines
  # Order by MetaPathway value.
  M.colord <- order(M.MetaPathwayValue)
  
  # Ensure that the cell lines (columns) in "M.yy" are the same as the cell lines used to create the MetaPathway.
  M.yy <- M.yy[ , match(colnames(M.MetaPathwayValue), colnames(M.yy))]
  
  # Create heatmaps and save them as pngs.
  png(paste0("Dasatinib_Metagenes_Output/Metapathway_Heatmaps/By_Metapathway_for_Thesis/", mpn, "_heatmap.png"), width = 204.92, height = 190, units = "mm", res = 600)
  par(cex.axis = 1, cex.lab = 1, cex.main = 1, mar = c(0, 0, 0, 0)) # mar = c(bottom, left, top, right)
  heatmap.mik(M.yy[ , M.colord],
              trace = 'none',
              scale = 'none',
              
              # Colours
              col = bluered(50),
              ColSideColors = M.cc[ , M.colord],
              
              # Axes (denodrograms and labels)
              Colv = FALSE, Rowv = TRUE, dendrogram = 'none',
              main = mpathname_title,
              xlab = "GDSC/CCLE Cell Lines",
              # ylab = "Metapathway\nGenes", srtRow = 0,
              # Setting size of column and row labels, but these are currently set to null so pointless.
              # cexCol = 8, cexRow = 32/nrow(M.yy),
              labCol = NA, labRow = NA,
              
              # Key
              key = T,
              keysize = 1, density.info = "none",
              key.ylab = "NA", key.xlab = " Normalised Gene Expression",
              
              # Margins
              mar = c(2, 10)
  )
  # Add an AUC and CHD1 expression legend and larger title.
  legend(x = 0.37, y = 0.935, legend = c("High AUC", "High CDH1 Expression", "High Metapathway Activity", "Low AUC", "Low CDH1 Expression", "Low Metapathway Activity"), fill = c("#FFEA46FF", "#F0F921FF", "#F0F921FF", "#00204DFF", "#0D0887FF", "#0D0887FF"), cex = 0.5, ncol = 2)
  # title(mpathname_title, cex.main = 1)
  mtext("Metapathway\nGenes", side = 4, las = 1, line = -4, padj = 5, adj = 0.5)
  dev.off()
}
```

# Calculate correlation between metagene and CDH1 expression for thesis.
```{r}
# Find correlations
M.CDH1MetageneCorY <- cor(t(M.pathMatSubsetY), t(M.CDH1Expression), method = "spearman") %>% na.omit(.)
M.CDH1MetageneCorY
```

## Test the MetaPathway Correlations
### Inspect the Data Used to Create MetaPathways, Trying to Find Correlations
```{r}
# Set parameters for this chunk.
par(mfrow=c(2,2))
# Plot AUC against MetaPathway value, coloured by MetaPathway value.
plot(M.MetaPathwayValue, M.drugAUC, col = M.MetaPathwaycols, pch = 16)
# Plot AUC against MetaPathway value, coloured by AUC value.
plot(M.MetaPathwayValue, M.drugAUC, col = M.expressioncols, pch = 16)
# Plot AUC against MetaPathway value, coloured by AUC value, and focussing on the highest values.
plot(M.MetaPathwayValue, M.drugAUC, col = M.MetaPathwaycols, pch = 16, ylim=c(0.3,1))

# See if there is a difference in the results when split by high and low AUC values.
AUC_High_Low <- ifelse(M.drugAUC > 0.3, "High", "Low")
boxplot(M.MetaPathwayValue ~ AUC_High_Low)

# Look for the strength of the correlation among the AUC values.
aucKp <- which(M.drugAUC > 0)
# Basic correlation test.
cor(M.MetaPathwayValue[aucKp], M.drugAUC[aucKp])
# With the Spearman method.
cor.test(M.MetaPathwayValue[aucKp], M.drugAUC[aucKp], method = 'spearman')
```

### Calculate How Much of the Variance in the Data is Explained by the First Two Eigenvectors

It can be quite difficult to extract the percentage variation explained from a Singular Value Decomposition (SVD) in R. However it can be done using a Principal Components Analysis (PCA). The results of a PCA will be relatively similar to those of an SVD, so the PCA can be used to approximate the percentage variation explained.
```{r}
# Set parameters for this chunk.
par(mfrow=c(1,2))
# Calculate a PCA on the MetaPathway 4 data for reference
M.dasPCA <- prcomp(M.xx)
# The first two principle components explain 15% and 12% of the variance respectively, 27% when combined.
summary(M.dasPCA)

# Comparing the results of the PCA and SVD shows that they are relatively consistent.
plot( M.sX$u[,1] * M.sX$d[1], M.dasPCA$x[,1], main="1st PC", xlab="SVD", ylab="PCA")
abline(0, 1, col='blue')
plot( M.sX$u[,2] * M.sX$d[2], M.dasPCA$x[,2], main="2nd PC", xlab="SVD", ylab="PCA")
abline(0, 1, col='blue')
```

27% is an acceptable estimate for percentage variation explained by the first two components of the SVD (for this combination of data).

# Now create a table to incorporate a lot of the information from this document as a supplementary material thesis table
```{r}
library(dplyr)

# Define metapathway descriptions
MetaPathwayDescriptions <-  list("Extracellular matrix interactions, organisation, and maintenance, laminin and integrin interactions, cell junctions, and cell communication.", "PI3K/AKT, ERBB family, and MAPK signaling", "Interleukin signaling, ion channel activity, and lipid metabolism.", "G protein-mediated signaling, ion channel and receptor-mediated signaling.")
names(MetaPathwayDescriptions) <- names(MetaPathwayContents)

# Create the table with simpler column names (these are automatically generated or simplified by R)
Table_Z <- data.frame(
  Metapathway = names(MetaPathways),  # Metapathway names from the list
  MetapathwayDescription = sapply(names(MetaPathways), function(metapathway_name) {
    # Extract the description from MetaPathwayDescriptions
    paste(MetaPathwayDescriptions[[metapathway_name]], collapse = ", ")
  }),
  CorrelatedCompounds = sapply(metapathway_drug_associations, paste, collapse = ", "),
  ReactomeTerms = sapply(filtered_MetaPathwayContents, paste, collapse = ", "),  # Join the terms with a comma
  Genes = sapply(conversion_results, paste, collapse = ", ")  # Join the gene symbols with a comma
)

# Loop through each row and update the "Metapathway" column
# Assuming you still have `conversion_results` and `filtered_MetaPathwayContents`
# which are the original lists used to create Table_Z.

# Update the "Metapathway" column with the desired format
Table_Z$Metapathway <- mapply(function(metapathway_name, idx) {
  # Length of the corresponding element in conversion_results and filtered_MetaPathwayContents
  genes_length <- length(conversion_results[[idx]])  # Get length from conversion_results
  pathways_length <- length(filtered_MetaPathwayContents[[idx]])  # Get length from filtered_MetaPathwayContents
  
  # Create the formatted string
  paste(metapathway_name, ": ", genes_length, " genes, ", pathways_length, " pathways", sep = "")
}, 
metapathway_name = Table_Z$Metapathway,  # Existing metapathway names
idx = seq_along(Table_Z$Metapathway))  # Index to access the corresponding lists


# View the updated Table_Z
head(Table_Z)

# Rename columns using dplyr::rename to match the more complex names
Table_Z <- Table_Z %>%
  dplyr::rename(
    "Description" = MetapathwayDescription,
    "Moderately or Greater Correlated Compounds (spearman rank correlation coefficient, 3 d.p.)" = CorrelatedCompounds,
    "Constituent Reactome Terms" = ReactomeTerms
  )

# Save this for incorporating into your thesis
write.csv(Table_Z, file = "Thesis/Supp_Table_Z.csv")
```

## Metapathways Without Matrix Multiplication
This code creates MetaPathways without using matrix multiplication (i.e the data is not transformed using dasatinib susceptible breast/gastric cancer cell data). This provides another view of the data, and how certain drugs may behave in cancer cells overall.
```{r}
# 'T.' denotes that these objects relate to a MetaPathway without matrix multiplication.

# Create "T.pathMatY".
T.pathMatY <- matrix(data = 0, length(MetaPathways), ncol(expDatAll))
rownames(T.pathMatY) <- names(MetaPathways)
colnames(T.pathMatY) <- colnames(expDatAll)

for(j in 1:length(MetaPathways)){
  # Create the matrix to build MetaPathways from.
  T.expDatAllY <- expDatAll
  # Convert rownames from Symbol ID's to ENSEMBL ID's to find the genes in "MetaPathways".
  rownames(T.expDatAllY) <- match(rownames(T.expDatAllY), GeneLabelTool$SYMBOL) %>% GeneLabelTool$ENSEMBL[.]
  # Find the rows in "MetaPathways".
  T.expDatAllY <- subset(T.expDatAllY, rownames(T.expDatAllY) %in% MetaPathways[[j]])
  # Scale the data.
  T.yy <- apply(T.expDatAllY, 1, scale, scale = TRUE) %>% t(.)
  colnames(T.yy) <- colnames(T.expDatAllY)
  
  # Create the MetaPathway.
  if(nrow(T.yy)>4){
    T.sY <- svd(T.yy)
    T.mgY <- T.sY$v[ ,1]
    # Add the MetaPathway values to the matrix of pathways by metagenes.
    T.pathMatY[j, ] <- T.mgY
  }
}

# Remove any duplicate columns from the pathway matrix.
T.pathMatY <- T.pathMatY[, !duplicated(colnames(T.pathMatY))]
```

### Find Correlations without Matrix Multiplication
```{r}
# Subset "T.AUCSamplesY" so it only includes cell lines that are present in "T.pathMatY", and vice versa.
T.AUCSamplesSubsetY <- select_if(as.data.frame(AUCSamplesY), colnames(AUCSamplesY) %in% colnames(T.pathMatY)) %>% 
  as.matrix(.)
T.pathMatSubsetY <- select_if(as.data.frame(T.pathMatY), colnames(T.pathMatY) %in% colnames(T.AUCSamplesSubsetY)) %>% 
  as.matrix(.)
T.AUCSamplesSubsetY <- subset(T.AUCSamplesSubsetY, colnames(T.AUCSamplesSubsetY) %in% colnames(T.pathMatSubsetY))

# Order the columns of each table in the same manner.
T.oo <- match(colnames(T.AUCSamplesSubsetY), colnames(T.pathMatSubsetY))
T.pathMatSubsetY <- T.pathMatSubsetY[,T.oo]

# Create a drug by pathway correlation matrix.
T.drugMetageneCorY <- cor(t(T.pathMatSubsetY), t(T.AUCSamplesSubsetY), method = "spearman") %>% na.omit(.)
```

### Create Heatmaps for Comparison to Matrix Multiplication Heatmaps - as PNGs
```{r, warning = FALSE}
for(p in 1:length(MetaPathways)){
  # Define which pathway is being worked on.
  mpathname <- names(MetaPathways)[p]
  mpn <- gsub(" ", "_", mpathname)
  # Create the gene expression matrix.
  T.expDatAllY <- expDatAll
  # Convert rownames from Symbol ID's to ENSEMBL ID's to find the genes in "MetaPathways".
  rownames(T.expDatAllY) <- match(rownames(T.expDatAllY), GeneLabelTool$SYMBOL) %>% GeneLabelTool$ENSEMBL[.]
  # Find the rows in MetaPathways
  T.expDatAllY <- subset(T.expDatAllY, rownames(T.expDatAllY) %in% MetaPathways[[p]])
  # Rename the rows with Symbol ID's.
  rownames(T.expDatAllY) <- match(rownames(T.expDatAllY), GeneLabelTool$ENSEMBL) %>% GeneLabelTool$SYMBOL[.]
  # Cut down on extreme values and scales the data.
  T.yy <- apply(T.expDatAllY, 1, scale, scale = TRUE) %>% t()
  colnames(T.yy) <- colnames(T.expDatAllY)
  T.yy[T.yy > 3] <- 3
  T.yy[T.yy < -3] <- -3
  
  # Create an object that says which drugs are significant, and is re-created for each pathway.
  T.aa <- subset(T.drugMetageneCorY, rownames(T.drugMetageneCorY) == mpathname)
  T.SigDrugs <- colSums(abs(T.aa)>cor.thresh) %>% sort(., decreasing = TRUE) %>% .[.>0]
  
  for(q in 1:length(T.SigDrugs)){
    if(length(T.SigDrugs > 0)){
      
      # Loop through the drugs involved with this pathway, and find an AUC for each.
      mdrugname <- names(T.SigDrugs)[q]
      mdn <- gsub(" ", "_", mdrugname)
      T.drugAUC <- subset(T.AUCSamplesSubsetY, rownames(T.AUCSamplesSubsetY) == mdrugname)
      # Create a colour strip for AUC values.
      T.expressioncols <- matrix((as.factor(T.drugAUC) %>% as.numeric() %>%
                                    cividis(length(table(.)), direction = 1)[.]), nrow = 1)
      rownames(T.expressioncols) <- "AUC"
      # Create a vector of cell lines that have AUC data.
      T.cell.lines <- intersect(colnames(T.drugAUC), colnames(T.pathMatY))
      
      # Create a matrix for the MetaPathway value.
      T.MetaPathwayValue <- T.pathMatY[p, T.cell.lines] %>% as.matrix(.) %>% t(.)
      rownames(T.MetaPathwayValue) <- rownames(T.pathMatY)[p]
      # Create a colour strip for the MetaPathway values.
      T.MetaPathwaycols <- matrix((as.factor(T.MetaPathwayValue) %>%
                                     as.numeric() %>% plasma(length(table(.)), direction = 1)[.]), nrow = nrow(T.MetaPathwayValue))
      rownames(T.MetaPathwaycols) <- paste0(rownames(T.MetaPathwayValue), " Metagene Value")
      
      # Create a matrix for metagene values (each representing a pathway) within the current MetaPathway.
      T.PathX <- intersect(rownames(pathMatY), MetaPathwayContents[[p]])
      # Cut this down so only the cell lines that have drug data are included.
      T.MetaPathwayContentsValue <- pathMatY[T.PathX, T.cell.lines]
      # Create a matrix of colours for each pathway.
      T.MetaPathwayContentscols <- matrix((as.factor(T.MetaPathwayContentsValue) %>%
                                             as.numeric() %>% inferno(length(table(.)), direction = 1)[.]), nrow = nrow(T.MetaPathwayContentsValue))
      rownames(T.MetaPathwayContentscols) <- rownames(T.MetaPathwayContentsValue)
      
      # Add CDH1 expression data.
      T.CDH1Expression <- tissueTool$CDH1_Expression[T.cell.lines, ] %>% as.matrix(.) %>% t(.)
      rownames(T.CDH1Expression) <- "CDH1 Expression"
      # Add a CDH1 expression data colour strip.
      T.CDH1Expressioncols <- matrix((as.factor(T.CDH1Expression) %>% 
                                        as.numeric() %>% plasma(length(table(.)), direction = 1)[.]), nrow = nrow(T.CDH1Expression))
      rownames(T.CDH1Expressioncols) <- rownames(T.CDH1Expression)
      # Add CDH1 expression level.
      T.CDH1Level <- tissueTool$CDH1_Level[T.cell.lines, ] %>% as.matrix(.) %>% t(.)
      rownames(T.CDH1Level) <- "CDH1 Expression Level"
      # Add a CDH1 expression level colour strip.
      T.CDH1Levelcols <- matrix((as.factor(T.CDH1Level) %>% 
                                   as.numeric() %>% plasma(length(table(.)), direction = -1)[.]), nrow = nrow(T.CDH1Level))
      rownames(T.CDH1Levelcols) <- rownames(T.CDH1Level)
      
      # Combine each of the colour matrices/strips.
      T.cc <- rbind(T.MetaPathwayContentscols, T.CDH1Expressioncols, T.CDH1Levelcols, T.MetaPathwaycols, T.expressioncols)
      colnames(T.cc) <- T.cell.lines
      # Order by AUC.
      # T.colord <- order(T.drugAUC)
      # Order by MetaPathway value.
      T.colord <- order(T.MetaPathwayValue)
      
      # Ensure that the cell lines (columns) used match the cell lines used to create the MetaPathways.
      T.yy <- T.yy[ , match(colnames(T.MetaPathwayValue), colnames(T.yy))]
      
      # Create heatmaps and save them as pngs.
      png(paste0("Dasatinib_Metagenes_Output/Metapathway_Heatmaps_No_MM/", mpn, "_", mdn, "_NO_MM_heatmap.png"), width = 4000, height = 4000)
      heatmap.mik(T.yy[ , T.colord],
                  trace = 'none',
                  scale = 'none',
                  col = bluered(50),
                  ColSideColors = T.cc[ , T.colord],
                  Colv = FALSE,
                  mar = c(4,50),
                  keysize = 1,
                  cexCol = 2, cexRow = 32/nrow(T.yy),
                  labCol = ""
      )
      # Add an AUC and CHD1 expression legend and larger title.
      legend(x = 0.4, y = 0.97, legend = c("High AUC", "High CDH1 Expression", "Low AUC", "Low CDH1 Expression"), fill = c( "#FFEA46FF", "#F0F921FF", "#00204DFF", "#0D0887FF"), cex = 3, ncol = 2)
      title(paste(mpathname, "-", mdrugname), cex.main = 3)
      dev.off()
    }
  }
}
```
