---
title: "4_Dasatinib_Susceptible_Pathways_in_Tumours"
author: "Kieran Redpath"
date: "30/03/2021"
output:
  html_document:
    theme: cosmo
    toc: true
    toc_depth: 3
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Summary

Finding pathways associated with dasatinib susceptibility in GDSC/CCLE cell lines, and then exploring these pathways in the TCGA and GEO (GSE) GC datasets.

## Setup

### Load packages
```{r, results='hide', warning=FALSE, message=FALSE}
library(limma)
library(edgeR)
library(data.table)
library(magrittr)
library(ggplot2)
library(CePa)
library(tibble)
library(tidyverse)
library(ggbeeswarm)
library(dplyr)
library(ReactomePA)
library(org.Hs.eg.db)
library(reactome.db)
library(goseq)
library(gplots)
source('Data/heatmap-mik.R')
library(knitr)
library(kableExtra)
library(devtools)
library(viridis)
set.seed(42)
```

### Load data
```{r, results='hide'}
# Loads in Entrez ID's from the human genome.
hs <- org.Hs.eg.db

# Loads expression data from the CCLE, and normalises it with "voom".
ccleExpData <- read.gct('Data/CCLE_RNAseq_genes_counts_20180929.gct')
logExpDat <- log(ccleExpData + 0.5)
dge <- DGEList(counts=ccleExpData)
dge <- calcNormFactors(dge)
dge_voom <- voom(dge, plot=TRUE)
expDat <- dge_voom$E
expDatsplit <- expDat

# Loads the GDSC dataset, and filters for cell lines that have data for dasatinib. 
GDSC2 <- fread('Data/GDSC2_fitted_dose_response_25Feb20.csv', sep= ';')
dim(GDSC2)
dasatinib <- GDSC2 %>% filter(., DRUG_NAME=="Dasatinib")
colnames(expDat) <- strsplit(colnames(expDat), "_") %>% 
  lapply(., function(x) x[1]) %>% 
  unlist()

# Filters for cell lines that are shared between the GDSC and CCLE datasets.
dasatinib$CELL_LINE_NAME <- gsub("-","",dasatinib$CELL_LINE_NAME, fixed=TRUE)
commonSamples <- intersect(dasatinib$CELL_LINE_NAME,colnames(expDat))
expDat_match <- match(commonSamples, colnames(expDat))
expDat_sort <- expDat[ , na.omit(expDat_match)]
dasatinib_match <- match(commonSamples, dasatinib$CELL_LINE_NAME)
dasatinib_sort <- dasatinib[na.omit(dasatinib_match),]
colnames(dasatinib_sort)[5] <- "CCLE_Name"

# Filters dasatinib data for the two tissues of interest, and removes the top 66% of samples (based on AUC), so that we're only looking at cell lines that are susceptible to dasatinib. Then filters "expDat_sort" so it's also only these cell lines, those that have data for the drug of interest, and CDH1 expression data.
# When you're only looking at susceptible cell lines, low AUC correlates to high efficacy (allegedly), so we only look at the bottom 33% of these cell lines. However, these still go up to 0.95 AUC, because there's lots of cell lines on which the drug has little effect.
dasatinib_sort <- dasatinib_sort %>% filter(., TCGA_DESC=="BRCA" | TCGA_DESC=="STAD")
dasatinib_sort <- dasatinib_sort[ dasatinib_sort$AUC < quantile(dasatinib_sort$AUC, 0.33) , ]
#                                  | dasatinib_sort$AUC > quantile(dasatinib_sort$AUC, 0.66), ]
dasatinib_sort$CDH1 <- expDat_sort %>% as.data.frame() %>% dplyr::select(., which(colnames(.) %in% dasatinib_sort$CCLE_Name)) %>%  .["ENSG00000039068.14",] %>% as.vector() %>% t()
expDat_sort <- expDat_sort %>% subset(., select=which(colnames(expDat_sort) %in% dasatinib_sort$CCLE_Name))

# Creates a tool for determining tissue type based on cell line identifier, or vice versa. Two versions are created, one for all tissues, the other for the three of interest (and specifically samples with expression data).
lng <- length(colnames(expDatsplit))
tissuetool <-data.frame(Cell_Line=character(lng),Tissue_Type=character(lng))
tissuetool$Cell_Line <- strsplit(colnames(expDatsplit), "_") %>% 
  lapply(., function(x) x[1]) %>% 
  unlist()
tissuetool$Tissue_Type <- strsplit(colnames(expDatsplit), "_") %>% 
  lapply(., function(x) x[-1])%>%
  paste(., sep="_", collapse = NULL) %>% 
  unlist()
tissuetool$Tissue_Type <- gsub('c', '', tissuetool$Tissue_Type)
tissuetool$Tissue_Type <- gsub('[[:punct:]]', '', tissuetool$Tissue_Type)
tissuetool$Tissue_Type <- gsub(' ', '_', tissuetool$Tissue_Type)
tissuetoolsort <- filter(tissuetool, Tissue_Type == "BREAST" | Tissue_Type == "STOMACH")

int <- intersect(colnames(expDat_sort), tissuetoolsort$Cell_Line)
tissuetool_match <- match(int, tissuetoolsort$Cell_Line)
tissuetoolsort <- tissuetoolsort[na.omit(tissuetool_match) , ]
```

### Load and process data for Gastric Cancer tissue datasets
```{r}
# Load GEO (GSE) data.
load('Data/gse62254_gastric_cancer.RData')
# Add sample names.
gse62254_clinDat <- gse62254_clinDat %>% mutate(., PatID = colnames(gse62254_expDat))
# Add CDH1 mutation status to the GSE dataset based on CDH1 expression level.
# Extract CDH1 expDat.
cdh1_gse_data <- gse62254_expDat[rownames(gse62254_expDat) == "CDH1"] %>% as.data.frame(.)
# Add sample names and column name.
rownames(cdh1_gse_data) <- colnames(gse62254_expDat)
colnames(cdh1_gse_data) <- "cdh1level"
# Create a vector for mutation status.
cdh1_gse_data$cdh1mut <- ifelse(cdh1_gse_data$cdh1level > 11, "0", "1")
# Plot this to check on your threshold. Not super confident on this.
ggplot(cdh1_gse_data, aes(x = "cdh1level", y = cdh1level, colour = cdh1mut)) +
  scale_color_viridis(discrete = TRUE, option = "cividis") +
  geom_beeswarm(show.legend = FALSE)
# Attach the mutation status column to gse62254_clinDat.
# gse62254_clinDat <- gse62254_clinDat %>% tibble::add_column(., cdh1mut = cdh1_gse_data$cdh1mut, .after = "ageCat")
# View(gse62254_clinDat)
# Cut down to... only diffuse? only EMT? both? cdh1mut?
gse_clinDat_HDGC_like <- filter(gse62254_clinDat, lc == "Diffuse")
# Cut down expDat from GEO to only include HDGC-like samples
gse_expDat_HDGC_like <- as.data.frame(gse62254_expDat) %>% dplyr::select(., which(colnames(.) %in% gse_clinDat_HDGC_like$PatID))


# Load TCGA data.
load('Data/tcga_gastric_cancer.RData')
# Add sample names.
tcga_clinDat <- tcga_clinDat %>% mutate(., PatID = colnames(tcga_expDat))
# Cut down samples to... only diffuse? only GS? both? cdh1mut?
tcga_clinDat_HDGC_like <- filter(tcga_clinDat, lc == "Diffuse")
# Cut down expDat from TCGA to only include HDGC-like samples
tcga_expDat_HDGC_like <- as.data.frame(tcga_expDat) %>% dplyr::select(., which(colnames(.) %in% tcga_clinDat_HDGC_like$PatID))
```

## Differential Expression Analysis

### Differential expression analysis for IC50
```{r}
# Prints some basic information about the objects that will be used for further analyses, for reference.
sum(colnames(expDat_sort)==dasatinib_sort$CCLE_Name)
names(dasatinib_sort)

# Fits the expression data to a linear model. 
group <- ifelse(dasatinib_sort$LN_IC50 > median(dasatinib_sort$LN_IC50), "High", "Low")
table(group)
boxplot(dasatinib_sort$LN_IC50 ~ group)
design = model.matrix(~group);
design %>% head()
colnames(design) = c("Mean"
                     ,"HighVsLow"
)
fit = lmFit(expDat_sort, design)
fit = eBayes(fit)
tt = topTable(fit, coef="HighVsLow", adjust="BH",n=nrow(expDat_sort))
options(digits=4)

# Plots the first gene on the list, and counts the number of significant samples (threshold of 0.01).
plot(density(expDat_sort[,1]))
sum(tt$adj.P.Val<0.05)

# Creates a volcano plot of the IC50 fold change vs. adjusted P value, showing significant samples with high fold change in red.
sigFC = (tt$adj.P.Val < 0.05)  & (abs(tt$logFC) > 1)
volcanoplot(fit, coef="HighVsLow")
points(tt$logFC[which(sigFC)], 
       -log10(tt$P.Value[which(sigFC)]), 
       cex=0.6, col='red', pch=16)
abline(h = min(-log10(tt$P.Value[which(sigFC)])), lty=2, col='blue')
abline(v = c(-1,1), lty=2, col='blue')

# Provides basic information on the top table.
split <- strsplit(rownames(tt),".", fixed=T) %>% lapply(., function(x) x[1]) %>% unlist()
geneNames <- AnnotationDbi::select(org.Hs.eg.db, keys = split, column = c("SYMBOL","GENENAME"), key="ENSEMBL")
dim(tt)
tt$symbol <- geneNames$SYMBOL[match(split, geneNames$ENSEMBL)]
invisible(setDT(tt, keep.rownames = TRUE)[])

# Prints a list of the top 50 associated genes (can be altered to create larger lists for pathway analysis). Also creates a histogram and shows the median of IC50 values.
# cat(na.omit(tt$symbol[1:50]),sep="\n")
hist(dasatinib_sort$LN_IC50,50)
median(dasatinib_sort$LN_IC50)

# Finds the top expression values, visualising the positive correlation between gene expression and IC50.
topExp <- expDat_sort[match(tt$rn[1], rownames(expDat_sort)),]
df <- data.frame(topGene=topExp, ic50=group)
ggplot(df, aes(x=ic50, y=topGene)) + geom_boxplot()
```

### Differential expression analysis for AUC
```{r}
# Prints some basic information about the objects that will be used for further analyses, for reference.
sum(colnames(expDat_sort)==dasatinib_sort$CCLE_Name)
names(dasatinib_sort)

# Fits the expression data to a linear model.
group2 <- ifelse(dasatinib_sort$AUC > median(dasatinib_sort$AUC), "High", "Low")
table(group2)
boxplot(dasatinib_sort$AUC ~ group2)
design2 = model.matrix(~group2);
design2 %>% head()
colnames(design2) = c("Mean"
                      ,"HighVsLow"
)
fit2 = lmFit(expDat_sort, design2)
fit2 = eBayes(fit2)
tt2 = topTable(fit2, coef="HighVsLow", adjust="BH",n=nrow(expDat_sort))
options(digits=4)

# Plots the first gene on the list, and counts the number of significant samples (threshold of 0.01).
plot(density(expDat_sort[,1]))
sum(tt2$adj.P.Val<0.05)

# Creates a volcano plot of the AUC fold change vs. adjusted P value, showing significant samples with high fold change in red.
sigFC2 = (tt2$adj.P.Val < 0.05)  & (abs(tt2$logFC) > 1)
volcanoplot(fit2, coef="HighVsLow")
points(tt2$logFC[which(sigFC2)], 
       -log10(tt2$P.Value[which(sigFC2)]), 
       cex=0.6, col='red', pch=16)
abline(h = min(-log10(tt2$P.Value[which(sigFC2)])), lty=2, col='blue')
abline(v = c(-1,1), lty=2, col='blue')

# Provides basic information on the top table, and prints the first 20 genes, for reference.
split2 <- strsplit(rownames(tt2),".", fixed=T) %>% lapply(., function(x) x[1]) %>% unlist()
geneNames2 <- AnnotationDbi::select(org.Hs.eg.db, keys = split2, column = c("SYMBOL","GENENAME"), key="ENSEMBL")
dim(tt2)
tt2$symbol <- geneNames2$SYMBOL[match(split2, geneNames2$ENSEMBL)]
invisible(setDT(tt2, keep.rownames = TRUE)[])
tt2[1:20,] %>% kable() %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed", font_size=8), fixed_thead=T)

# Prints a list of the top 50 associated genes (can be altered to create larger lists for pathway analysis). Also creates a histogram and shows the median of AUC values.
cat(na.omit(tt2$symbol[1:50]),sep="\n")
hist(dasatinib_sort$AUC,50)
median(dasatinib_sort$AUC)

# Finds the top expression values, visualising the negative correlation between gene expression and AUC.
topExp2 <- expDat_sort[match(tt2$rn[1], rownames(expDat_sort)),]
df2 <- data.frame(topGene=topExp2, AUC=group)
ggplot(df2, aes(x=AUC, y=topGene)) + geom_boxplot()
```

## Processing IC50 and AUC Differential Expression Data

### Finding the overlap between significant samples
* This information (present in top table 3) will be used for pathway analysis.
```{r}
# Creates a new top table, containing the information for both IC50 and AUC, with ensembl ID's and gene symbols.
tt3 <- full_join(tt, tt2, by= "rn")
tt3 <- dplyr::select(tt3, -c("symbol.x", "P.Value.y", "P.Value.x", "t.y", "t.x", "B.x", "B.y", "AveExpr.x"))
tt3 <- dplyr::rename(tt3, "Gene_Symbol" = "symbol.y", "AUC_logFC" = "logFC.y", "Avg_Exp" = "AveExpr.y", "AUC_Adj_PVal" = "adj.P.Val.y", "IC50_logFC" = "logFC.x", "IC50_Adj_PVal" = "adj.P.Val.x", "Ensembl_ID" = "rn")
tt3 <- tt3[ ,c(7,1,5,2,3,4,6)]

# Identifies that the sign of the log fold change is consistent with the IC50 and AUC relationship. As IC50 and AUC have an opposite association with cell line resistance/susceptibility to dasatinib, only samples with -log fold change signs (IC50 log FC sign*AUC log FC sign) are kept. Need to check this.
tt3 <- mutate(tt3, sign(tt3$IC50_logFC), sign(tt3$AUC_logFC))
tt3 <- mutate(tt3, sign(tt3$IC50_logFC)*sign(tt3$AUC_logFC))
tt3 <- dplyr::rename(tt3, "logFC_Sign" = "sign(tt3$IC50_logFC) * sign(tt3$AUC_logFC)", "IC50_Sign" = "sign(tt3$IC50_logFC)", "AUC_Sign" = "sign(tt3$AUC_logFC)")

# Ranks samples based on average rank between IC50 and AUC adjusted P values.
tt3 <-
  tt3 %>% mutate(., rank_ic50=rank(IC50_Adj_PVal)) %>%
  mutate(., rank_auc=rank(AUC_Adj_PVal)) %>%
  mutate(., avg_rank=0.5*(rank_auc + rank_ic50)) %>%
  arrange(., avg_rank)
```

## Pathway Analysis

### GoSeq analysis with the top genes
* "goseq" corrects for gene length.
```{r, warning=FALSE, message=FALSE}
# Defines the significant samples. This is based on positive log fold change sign (IC50 sign*AUC sign), and an absolute log fold change of log2(2) for both IC50 and AUC. Ranks samples based on adjusted p value, averaged between IC50 and AUC.
SigSamples <- filter(tt3, tt3$logFC_Sign == 1, abs(tt3$IC50_logFC) > log2(2), abs(tt3$AUC_logFC) > log2(2))
SigSamples <- 
  SigSamples %>% mutate(., rank_ic50=rank(IC50_Adj_PVal)) %>%
  mutate(., rank_auc=rank(AUC_Adj_PVal)) %>% 
  mutate(., avg_rank=0.5*(rank_auc + rank_ic50)) %>% 
  arrange(., avg_rank)

# Cuts down to the top 2000 significant samples, for pathway analysis, and adds Entrez ID's to these.
# Test using all samples
#  <- SigSamples[1:2000,]
TopXGenes <- as.character(na.omit(SigSamples$Gene_Symbol))
TopXGenesEntrez <- AnnotationDbi::select(hs, 
                                         keys = TopXGenes,
                                         columns = c("ENTREZID", "SYMBOL"),
                                         keytype = "SYMBOL")

# Adds Entrez ID's to and define non-significant samples.
tt3Genes <- as.character(na.omit(tt3$Gene_Symbol))
tt3GenesEntrez <- AnnotationDbi::select(hs, 
                                        keys = tt3Genes,
                                        columns = c("ENTREZID", "SYMBOL"),
                                        keytype = "SYMBOL")

# Gets pathway names and extracts human-only pathways. Also defines the intersect of the significant genes and those that are in reactome.
rName <- as.list(reactomePATHNAME2ID)
rName <- rName[grep("Homo sapiens", names(rName))]
rGenes <- as.list(reactomePATHID2EXTID)
rGenesPath <- rGenes[match(rName, names(rGenes))]
rGenesPath <- lapply(rGenesPath, unique)
rGeneByPath <- as.list(reactomeEXTID2PATHID)
allGenes <- intersect( tt3GenesEntrez$ENTREZID, unique(unlist(rGenesPath)) )
length(allGenes)
sigGenes <- intersect( TopXGenesEntrez$ENTREZID, unique(unlist(rGenesPath)) )
length(sigGenes)
plotGenes <- rep(0, length(allGenes))
names(plotGenes) <- allGenes
plotGenes[match(sigGenes, names(plotGenes))] <- 1

# Counts the number of significant genes (1's) and non-significant genes (0's). Finds the genes relevant to your dataset.
table(plotGenes)
mt <- match(allGenes, names(rGeneByPath))
rGeneByPath <- lapply(rGeneByPath[mt], function(x) intersect(x, names(rGenesPath)))

# Carries out the length-corrected goseq analysis: The Venn diagram shows that most of the pathways are the same between the two. 
pwf <- nullp(plotGenes, 'hg19', id = "knownGene", plot.fit = TRUE)
goseqReactome <- goseq(pwf, gene2cat = rGeneByPath)
goseqReactome$adjP <- p.adjust(goseqReactome$over_represented_pvalue, method = "fdr")

# Filters the length-corrected pathways for significance (threshold of 0.05) and adds pathway information.
goseqPathways <- filter(goseqReactome, goseqReactome$adjP <1)
rPathName <- as.list(reactomePATHID2NAME)
goseqPathways$Pathway <- gsub("Homo sapiens: ", "", rPathName[match(goseqPathways$category, names(rPathName))])
goseqPathways[,2:6] <- round(as.numeric(unlist(goseqPathways[,2:6])), digits=4)
SiggoseqPathways <- goseqPathways
```


### Extract genes from GoSeq pathway analysis
* Adds more information to "goseqPathways", so we can directly identify the genes involved.
```{r}
# Creates a tool to easily match genes, between gene symbol, entrez ID, and ensembl ID.
GeneLabelTool <- dplyr::pull(tt3, Gene_Symbol)
GeneLabelTool <- AnnotationDbi::select(hs,
                                       keys = GeneLabelTool,
                                       columns = c("ENSEMBL", "ENTREZID", "SYMBOL"),
                                       keytype = "SYMBOL")

# Creates a list of significant genes for each goseq pathway, converts them to symbol ID's. Also does the same for all the genes in each pathway and adds the information to "goseqPathways".
SiggenesinPaths <-list()
for(i in 1:nrow(goseqPathways)){
  SiggenesinPaths[[i]] <- rGenesPath[match(goseqPathways$category[i], names(rGenesPath))] %>% 
    .[[1]] %>% 
    intersect(., rownames(pwf)[pwf$DEgenes==1])
}

genesinPaths <- list()
for(i in 1:nrow(goseqPathways)){
  genesinPaths[[i]] <- rGenesPath[match(goseqPathways$category[i], names(rGenesPath))] %>% 
    .[[1]] %>% 
    intersect(., rownames(pwf)[pwf$DEgenes==1 | pwf$DEgenes==0])
}
SigsymbolsinPaths <- lapply(SiggenesinPaths, function(x) GeneLabelTool$SYMBOL[na.omit(match(x, GeneLabelTool$ENTREZID))] )
symbolsinPaths <- lapply(genesinPaths, function(x) GeneLabelTool$SYMBOL[na.omit(match(x, GeneLabelTool$ENTREZID))] )

# Save the object that's loaded in to calculate metagenes.
ensginPaths <- lapply(genesinPaths, function(x) GeneLabelTool$ENSEMBL[na.omit(match(x, GeneLabelTool$ENTREZID))] )
saveRDS(ensginPaths, file = "Dasatinib_Susceptible_Pathways_in_Tumours_Output/Other/Ensembl_ID_in_Paths.Rds")

genesStick <- lapply(symbolsinPaths, function(x) paste0(x, collapse="::", sep="")) %>% unlist()
goseqPathways$DEgenesInCat <- genesStick
goseqPathways <- lapply(goseqPathways, gsub, pattern='/', replacement=' ') %>% as.data.frame()
goseqPathways$Pathway <- lapply(goseqPathways$Pathway, gsub, pattern=':', replacement='-')
goseqPathways$Pathway <- lapply(goseqPathways$Pathway, gsub, pattern='Insulin-like Growth Factor', replacement='IGF')

# Gives a table with which to identify the genes involved in each pathway, and saves it.
SiggenesStick <- lapply(SigsymbolsinPaths, function(x) paste0(x, collapse="::", sep="")) %>% unlist()
SiggoseqPathways$DEgenesInCat <- SiggenesStick
SiggoseqPathways <- lapply(SiggoseqPathways, gsub, pattern='/', replacement=' ') %>% as.data.frame()
SiggoseqPathways$Pathway <- lapply(SiggoseqPathways$Pathway, gsub, pattern=':', replacement='-')
SiggoseqPathways$Pathway <- lapply(SiggoseqPathways$Pathway, gsub, pattern='Insulin-like Growth Factor', replacement='IGF')
SiggoseqPathways$Pathway <- as.character(SiggoseqPathways$Pathway)
write.csv(SiggoseqPathways, file = "Dasatinib_Susceptible_Pathways_in_Tumours_Output/Other/goseq_Das_Pathways.csv")
```

## Investigate the significant pathways in the TCGA dataset.

### Create metagenes for the TCGA dataset.
```{r}
pathMatY <- matrix(data = 0, length(rownames(SiggoseqPathways)[as.numeric(SiggoseqPathways$adjP) < 0.05]), ncol(tcga_expDat))
rownames(pathMatY) <- goseqPathways$Pathway[1:nrow(pathMatY)]
colnames(pathMatY) <- colnames(tcga_expDat)

# Carry out matrix multiplication to transform "PathMatY".
for(j in 1:length(rownames(SiggoseqPathways)[as.numeric(SiggoseqPathways$adjP) < 0.05])){
  # Create "xx".
  pathway_expDat_Dasatinib <- subset(tcga_expDat, rownames(tcga_expDat) %in% symbolsinPaths[[j]])
  xx <- apply(pathway_expDat_Dasatinib, 1, scale, scale = TRUE) %>% t()
  colnames(xx) <- colnames(pathway_expDat_Dasatinib)
  
  # Create the pathway/metagene matrix, doesn't really work for metagenes with so few genes involved, so they are discounted.
  if(nrow(xx)>4){
    
    # Subset "expDatAll" so it only contains the genes found in "xx".
    expDatAllY <- subset(tcga_expDat, rownames(tcga_expDat) %in% rownames(xx))
    expDatAllYNames <- expDatAllY
    expDatAllY <- apply(expDatAllY, 1, scale, scale = TRUE) %>% t()
    colnames(expDatAllY) <- colnames(expDatAllYNames)
    # Remove Duplicates
    expDatAllY <- expDatAllY[!duplicated(rownames(expDatAllY)), ]
    
    # Subset "xx" so it only contains the genes also found in "expDatAllY".
    xx <- subset(xx, rownames(xx) %in% rownames(expDatAllY))
    
    # Create the metagene.
    sX <- svd(xx)
    mgX <- sX$v[ ,1]
    # Add the metagenes to the matrix of pathways vs metagenes, "pathMatY".
    pathMatY[j, ] <- mgX
  }
}  

# Remove any duplicate columns from the pathway matrix.
pathMatY <- pathMatY[, !duplicated(colnames(pathMatY))]

# Save pathMatY to explore different components of SVD
write.csv(pathMatY, file = "PCAExplore/pathMatY_TCGA_1.csv")
```

### Create heatmaps for TCGA data with metagenes mapped across the top.
```{r}
# Create an empty vector to fill within the loop
GenePath_Cor_TCGA <- vector(mode = "list", length = length(rownames(SiggoseqPathways)[as.numeric(SiggoseqPathways$adjP) < 0.05]))

# Create heatmaps of gene expression in pathways within TCGA dataset.

for(m in 1:length(rownames(SiggoseqPathways)[as.numeric(SiggoseqPathways$adjP) < 0.05])){
  # Fetches expression data
  pathway_expDat <- subset(tcga_expDat, rownames(tcga_expDat) %in% symbolsinPaths[[m]])
  zz <- apply(pathway_expDat, 1, scale, scale=TRUE) %>% t(.)
  colnames(zz) <- colnames(pathway_expDat)
  
  # Order zz in the same order as symbolsinpaths[[m]]
  orderer <- as.vector(symbolsinPaths[[m]])
  new_order <- sapply(orderer, function(x,zz){which(rownames(zz) == x)}, zz=zz) %>% unlist(.)
  zz <- zz[new_order, ]
  
  cc <- rbind((as.factor(tcga_clinDat$lc) %>% as.numeric(.) %>% rainbow(length(table(.)))[.]),
              as.factor(tcga_clinDat$cdh1mut) %>% as.numeric(.) %>% cividis(length(table(.)))[.],
              as.factor(pathMatY[m, ]) %>% as.numeric(.) %>% cividis(length(table(.)))[.]
  )
  rownames(cc) <- c("Lauren Classification", "CDH1 Mut Status", "Metagene Value")
  colord = order(cc["Metagene Value", ])
  
  # Orders rows and sorts out colours
  msymbolsinPaths <- subset(symbolsinPaths[[m]], subset = symbolsinPaths[[m]] %in% rownames(zz))
  rowcc <- rep("red2", length(msymbolsinPaths))
  rowcc[which(msymbolsinPaths %in% SigsymbolsinPaths[[m]])] = "chartreuse2"
  roword <- as.factor(rowcc) %>% as.numeric(.) %>% order(.)
  
  # Changes row label font size based on how many rows there are, to avoid clutter.
  fonthelp <- length(symbolsinPaths[[m]])
  fontdefault <-  0.2 + 1/log10(fonthelp)
  l <- ifelse(fonthelp>200, 0.4, fontdefault)
  # Standardises extreme values for better heatmaps, and ensures they aren't created for pathways with few enriched genes.
  if(length(symbolsinPaths[[m]])>1){
    zz[zz > 3] <- 3
    zz[zz < -3] <- -3
    # Creates the heatmaps.
    pn <- gsub(" ", "_", goseqPathways$Pathway[m])
    png(paste0("Dasatinib_Susceptible_Pathways_in_Tumours_Output/Metagene_Heatmaps/", pn, "_TCGA_heatmap.png"), width = 20, height = 20, units = 'in', res = 500)
    
    # heatmap.mik(zz[roword,colord], trace = "none", scale = "none", col = bluered(50), ColSideColors = cc[, colord], Colv = FALSE, RowSideColors = rowcc[roword], Rowv = FALSE, mar = c(4,12), keysize = 1, cexRow = l, main=(goseqPathways$Pathways[m]))
    
    heatmap.mik(zz[,colord], trace = "none", scale = "none", col = bluered(50), ColSideColors = cc[, colord], Colv = FALSE, RowSideColors = rowcc, Rowv = TRUE, mar = c(4,12), keysize = 1, cexRow = l, main=(goseqPathways$Pathways[m]))
    
    
    
    legend(0.5,0.97,
           c("Diffuse lc", "Mixed lc", "High CDH1 (CDH1+)", "No data CDH1", "High Metagene Value", "Significant Genes", "Intestinal lc", "No data lc", "Low CDH1 (CDH1-)", "", "Low Metagene Value", "Not Significant Genes"),
           fill=c("#FF0000", "#0000FF", "#00204DFF", "#FFFFFF", "#00204DFF", "chartreuse2","#00FF00", "#FFFFFF", "#FFEA46FF", "#FFFFFF", "#FFEA46FF", "red2"), border="White", ncol=2)
    title(paste0(goseqPathways$Pathway[m], " in TCGA Datasets"), cex.main = 3)
    dev.off()
  }
  
  # Create a vector to fill with gene names and correlations:
  sm <- vector(mode = "double", length = nrow(zz))
  names(sm) <- rownames(zz)
  
  # Find correlations
  for(s in 1:nrow(zz)){
    sm[s] <- cor(zz[s, ], pathMatY[m, ], method = "spearman")
  }
  # Fill the list with correlations and gene names for each pathway
  GenePath_Cor_TCGA[[m]] <- sm
  names(GenePath_Cor_TCGA)[m] <- (SiggoseqPathways$Pathway[as.numeric(SiggoseqPathways$adjP) < 0.05])[m]
}
```

### Explore strong gene/metagene correlations to find genes that strongly represent a given metagene
```{r}
# Look at genes that correlate more strongly to the metagene value
GenePath_Cor_Strong_TCGA <- lapply(GenePath_Cor_TCGA, function(x){
  x[abs(x) > 0.7]
})
```

### Create metagenes for the GEO dataset.
```{r}
pathMatY <- matrix(data = 0, length(rownames(SiggoseqPathways)[as.numeric(SiggoseqPathways$adjP) < 0.05]), ncol(gse62254_expDat))
rownames(pathMatY) <- goseqPathways$Pathway[1:nrow(pathMatY)]
colnames(pathMatY) <- colnames(gse62254_expDat)

# Carry out matrix multiplication to transform "PathMatY".
for(j in 1:length(rownames(SiggoseqPathways)[as.numeric(SiggoseqPathways$adjP) < 0.05])){
  # Create "xx".
  pathway_expDat_Dasatinib <- subset(gse62254_expDat, rownames(gse62254_expDat) %in% symbolsinPaths[[j]])
  xx <- apply(pathway_expDat_Dasatinib, 1, scale, scale = TRUE) %>% t()
  colnames(xx) <- colnames(pathway_expDat_Dasatinib)
  
  # Create the pathway/metagene matrix, doesn't really work for metagenes with so few genes involved, so they are discounted.
  if(nrow(xx)>4){
    
    # Subset "expDatAll" so it only contains the genes found in "xx".
    expDatAllY <- subset(gse62254_expDat, rownames(gse62254_expDat) %in% rownames(xx))
    expDatAllYNames <- expDatAllY
    expDatAllY <- apply(expDatAllY, 1, scale, scale = TRUE) %>% t()
    colnames(expDatAllY) <- colnames(expDatAllYNames)
    # Remove Duplicates
    expDatAllY <- expDatAllY[!duplicated(rownames(expDatAllY)), ]
    
    # Subset "xx" so it only contains the genes also found in "expDatAllY".
    xx <- subset(xx, rownames(xx) %in% rownames(expDatAllY))
    
    # Create the metagene.
    sX <- svd(xx)
    mgX <- sX$v[ ,1]
    # Add the metagenes to the matrix of pathways vs metagenes, "pathMatY".
    pathMatY[j, ] <- mgX
  }
}  

# Remove any duplicate columns from the pathway matrix.
pathMatY <- pathMatY[, !duplicated(colnames(pathMatY))]

# Save pathMatY to explore different components of SVD
write.csv(pathMatY, file = "PCAExplore/pathMatY_GEO_1.csv")
```

### Create heatmaps for GEO data with metagenes mapped across the top.
```{r}
# Create an empty vector to fill within the loop
GenePath_Cor_GEO <- vector(mode = "list", length = length(rownames(SiggoseqPathways)[as.numeric(SiggoseqPathways$adjP) < 0.05]))

# Create heatmaps of gene expression in pathways within GEO dataset.

for(m in 1:length(rownames(SiggoseqPathways)[as.numeric(SiggoseqPathways$adjP) < 0.05])){
  # Fetches expression data
  pathway_expDat <- subset(gse62254_expDat, rownames(gse62254_expDat) %in% symbolsinPaths[[m]])
  zz <- apply(pathway_expDat, 1, scale, scale=TRUE) %>% t(.)
  colnames(zz) <- colnames(pathway_expDat)
  
  # Order zz in the same order as symbolsinpaths[[m]]
  orderer <- as.vector(symbolsinPaths[[m]])
  new_order <- sapply(orderer, function(x,zz){which(rownames(zz) == x)}, zz=zz) %>% unlist(.)
  zz <- zz[new_order, ]
  
  cc <- rbind((as.factor(gse62254_clinDat$lc) %>% as.numeric(.) %>% rainbow(length(table(.)))[.]),
              as.factor(pathMatY[m, ]) %>% as.numeric(.) %>% cividis(length(table(.)))[.]
  )
  rownames(cc) <- c("Lauren Classification", "Metagene Value")
  colord = order(cc["Metagene Value", ])
  
  # Orders rows and sorts out colours
  msymbolsinPaths <- subset(symbolsinPaths[[m]], subset = symbolsinPaths[[m]] %in% rownames(zz))
  rowcc <- rep("red2", length(msymbolsinPaths))
  rowcc[which(msymbolsinPaths %in% SigsymbolsinPaths[[m]])] = "chartreuse2"
  roword <- as.factor(rowcc) %>% as.numeric(.) %>% order(.)
  
  # Changes row label font size based on how many rows there are, to avoid clutter.
  fonthelp <- length(symbolsinPaths[[m]])
  fontdefault <-  0.2 + 1/log10(fonthelp)
  l <- ifelse(fonthelp>200, 0.4, fontdefault)
  # Standardises extreme values for better heatmaps, and ensures they aren't created for pathways with few enriched genes.
  if(length(symbolsinPaths[[m]])>1){
    zz[zz > 3] <- 3
    zz[zz < -3] <- -3
    # Creates the heatmaps.
    pn <- gsub(" ", "_", goseqPathways$Pathway[m])
    png(paste0("Dasatinib_Susceptible_Pathways_in_Tumours_Output/Metagene_Heatmaps/", pn, "_GEO_heatmap.png"), width = 20, height = 20, units = 'in', res = 500)
    # heatmap.mik(zz[roword,colord], trace = "none", scale = "none", col = bluered(50), ColSideColors = cc[, colord], Colv = FALSE, RowSideColors = rowcc[roword], Rowv = FALSE, mar = c(4,12), keysize = 1, cexRow = l, main=(goseqPathways$Pathways[m]))
    
    heatmap.mik(zz[,colord], trace = "none", scale = "none", col = bluered(50), ColSideColors = cc[, colord], Colv = FALSE, RowSideColors = rowcc, Rowv = TRUE, mar = c(4,12), keysize = 1, cexRow = l, main=(goseqPathways$Pathways[m]))
    
    legend(0.5,0.97,
           c("Diffuse lc", "Mixed lc", "High Metagene Value", "Significant Genes", "Intestinal lc", "No data lc", "Low Metagene Value", "Not Significant Genes"),
           fill=c("#FF0000", "#0000FF", "#00204DFF", "chartreuse2","#00FF00", "#FFFFFF", "#FFEA46FF", "red2"), border="White", ncol=2)
    title(paste0(goseqPathways$Pathway[m], " in GEO Datasets"), cex.main = 3)
    dev.off()
  }
  
  # Create a vector to fill with gene names and correlations:
  sm <- vector(mode = "double", length = nrow(zz))
  names(sm) <- rownames(zz)
  
  # Find correlations
  for(s in 1:nrow(zz)){
    sm[s] <- cor(zz[s, ], pathMatY[m, ], method = "spearman")
  }
  # Fill the list with correlations and gene names for each pathway
  GenePath_Cor_GEO[[m]] <- sm
  names(GenePath_Cor_GEO)[m] <- (SiggoseqPathways$Pathway[as.numeric(SiggoseqPathways$adjP) < 0.05])[m]
}
```

### Explore strong gene/metagene correlations to find genes that strongly represent a given metagene
```{r}
# Look at genes that correlate more strongly to the metagene value
GenePath_Cor_Strong_GEO <- lapply(GenePath_Cor_GEO, function(x){
  x[abs(x) > 0.7]
})

# Try figure out how to do the stuff in the above loop with apply
# Use lapply (for lists) or mapply (for multivariates), one of these should work
# This is definitely wrong.
# 
# GenePath_Cor_GEO <- lapply(zz, function(x){
#   sm <- cor(x, pathMatY[m], method = "spearman")
#   x[[m]] <- sm
# })

```

### Find the genes shared between each list
```{r}
# Create list of overlap with pathway names
GenePath_Cor_Strong_Both <- vector(mode = "list", length = length(GenePath_Cor_Strong_GEO))
names(GenePath_Cor_Strong_Both) <- names(GenePath_Cor_Strong_GEO)

# Loop through and find matching elements in each part of the list
for(a in 1:length(GenePath_Cor_Strong_GEO)){
GenePath_Cor_Strong_Both[[a]] <- intersect(names(GenePath_Cor_Strong_GEO[[a]]), names(GenePath_Cor_Strong_TCGA[[a]]) )
}
View(GenePath_Cor_Strong_Both)
```

